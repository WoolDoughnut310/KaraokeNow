System.register(["jotai/vanilla/utils","jotai","react"],function(N){"use strict";var E,S,m,W,C,M,V,I,T,j;return{setters:[function(b){E=b.RESET,S=b.unstable_NO_STORAGE_VALUE,N({RESET:b.RESET,unstable_NO_STORAGE_VALUE:b.unstable_NO_STORAGE_VALUE})},function(b){m=b.atom,W=b.SECRET_INTERNAL_getScopeContext,C=b.useAtom,M=b.useSetAtom,V=b.SECRET_INTERNAL_registerPromiseAbort,N({useAtomValue:b.useAtomValue,useUpdateAtom:b.useSetAtom})},function(b){I=b.useContext,T=b.useCallback,j=b.useMemo}],execute:function(){N({abortableAtom:yt,atomFamily:q,atomWithDefault:at,atomWithHash:ht,atomWithObservable:dt,atomWithReducer:K,atomWithReset:b,atomWithStorage:J,createJSONStorage:z,freezeAtom:et,freezeAtomCreator:nt,loadable:gt,selectAtom:Y,splitAtom:st,useAtomCallback:Z,useHydrateAtoms:bt,useReducerAtom:$,useResetAtom:H,waitForAll:ut});function b(t){const n=m(t,(o,s,r)=>{const e=typeof r=="function"?r(o(n)):r;s(n,e===E?t:e)});return n}const F="w",G="h";function H(t,n){const o=W(n),s=I(o).s;return T(()=>s[F](t,E),[s,t])}function $(t,n,o){const[s,r]=C(t,o),e=T(a=>{r(i=>n(i,a))},[r,n]);return[s,e]}function K(t,n){const o=m(t,(s,r,e)=>r(o,n(s(o),e)));return o}function q(t,n){let o=null;const s=new Map,r=e=>{let a;if(n===void 0)a=s.get(e);else for(const[c,u]of s)if(n(c,e)){a=u;break}if(a!==void 0)if(o!=null&&o(a[1],e))r.remove(e);else return a[0];const i=t(e);return s.set(e,[i,Date.now()]),i};return r.remove=e=>{if(n===void 0)s.delete(e);else for(const[a]of s)if(n(a,e)){s.delete(a);break}},r.setShouldRemove=e=>{if(o=e,!!o)for(const[a,i]of s)o(i[1],a)&&s.delete(a)},r}const B=(t,n)=>{do{const[o,...s]=n,r=t.get(o);if(!r)return;if(!s.length)return r[1];t=r[0],n=s}while(n.length)},Q=(t,n,o)=>{do{const[s,...r]=n;let e=t.get(s);if(e||(e=[new WeakMap],t.set(s,e)),!r.length){e[1]=o;return}t=e[0],n=r}while(n.length)},O=()=>{const t=new WeakMap;return(n,o)=>{const s=B(t,o);if(s)return s;const r=n();return Q(t,o,r),r}},X=O();function Y(t,n,o=Object.is){return X(()=>{const s=m(()=>({}));return m(r=>{const e=n(r(t)),a=r(s);return"prev"in a&&o(a.prev,e)?a.prev:(a.prev=e,e)})},[t,n,o])}function Z(t,n){const o=j(()=>m(null,(r,e,[a,i,c])=>{try{i(t(r,e,a))}catch(u){c(u)}}),[t]),s=M(o,n);return T(r=>{let e=!0,a={};const i=new Promise((c,u)=>{s([r,l=>{e?a={v:l}:c(l)},l=>{e?a={e:l}:u(l)}])});if(e=!1,"e"in a)throw a.e;return"v"in a?a.v:i},[s])}const tt=O(),P=t=>{if(typeof t!="object"||t===null)return;Object.freeze(t);const n=Object.getOwnPropertyNames(t);for(const o of n){const s=t[o];P(s)}return t};function et(t){return tt(()=>m(n=>P(n(t)),(n,o,s)=>o(t,s)),[t])}function nt(t){return(...n)=>{const o=t(...n),s=o.read;return o.read=r=>P(s(r)),o}}const rt=O(),U=t=>!!t.write,ot=t=>typeof t=="function";function st(t,n){return rt(()=>{const o=new WeakMap,s=(c,u)=>{let l=o.get(c);if(l)return l;const f=u&&o.get(u),d=[],h=[];return c.forEach((y,w)=>{const A=n?n(y):w;h[w]=A;const R=f&&f.atomList[f.keyList.indexOf(A)];if(R){d[w]=R;return}const v=L=>{const x=L(r),p=L(t),_=s(p,x.prev).keyList.indexOf(A);if(_<0||_>=p.length){const g=c[s(c).keyList.indexOf(A)];if(g)return g;throw new Error("splitAtom: index out of bounds for read")}return p[_]},pt=(L,x,p)=>{const _=L(r),g=L(t),k=s(g,_.prev).keyList.indexOf(A);if(k<0||k>=g.length)throw new Error("splitAtom: index out of bounds for write");const St=ot(p)?p(g[k]):p;x(t,[...g.slice(0,k),St,...g.slice(k+1)])};d[w]=U(t)?m(v,pt):m(v)}),f&&f.keyList.length===h.length&&f.keyList.every((y,w)=>y===h[w])?l=f:l={atomList:d,keyList:h},o.set(c,l),l},r=m(()=>({})),e=c=>{const u=c(r),l=c(t),f=s(l,u.prev);return u.prev=l,f.atomList},a=(c,u,l)=>{switch("read"in l&&(console.warn("atomToRemove is deprecated. use action with type"),l={type:"remove",atom:l}),l.type){case"remove":{const f=c(i).indexOf(l.atom);if(f>=0){const d=c(t);u(t,[...d.slice(0,f),...d.slice(f+1)])}break}case"insert":{const f=l.before?c(i).indexOf(l.before):c(i).length;if(f>=0){const d=c(t);u(t,[...d.slice(0,f),l.value,...d.slice(f)])}break}case"move":{const f=c(i).indexOf(l.atom),d=l.before?c(i).indexOf(l.before):c(i).length;if(f>=0&&d>=0){const h=c(t);f<d?u(t,[...h.slice(0,f),...h.slice(f+1,d),h[f],...h.slice(d)]):u(t,[...h.slice(0,d),h[f],...h.slice(d,f),...h.slice(f+1)])}break}}},i=U(t)?m(e,a):m(e);return i},n?[t,n]:[t])}function at(t){const n=Symbol(),o=m(n),s=m(r=>{const e=r(o);return e!==n?e:t(r)},(r,e,a)=>a===E?e(o,n):e(o,typeof a=="function"?a(r(s)):a));return s}const it=O(),ct=m(()=>[]);function ut(t){const n=()=>{const o=lt(t);return m(s=>{const r=[],e=o.map((a,i)=>{try{return s(a)}catch(c){if(c instanceof Promise)r[i]=c;else throw c}});if(r.length)throw Promise.all(r);return ft(t,e)})};return Array.isArray(t)?t.length?it(n,t):ct:n()}const lt=t=>Array.isArray(t)?t:Object.getOwnPropertyNames(t).map(n=>t[n]),ft=(t,n)=>Array.isArray(t)?n:Object.getOwnPropertyNames(t).reduce((o,s,r)=>({...o,[s]:n[r]}),{});function z(t){let n,o;const s={getItem:r=>{var e,a;const i=u=>{if(u=u||"",n!==u){try{o=JSON.parse(u)}catch{return S}n=u}return o},c=(a=(e=t())==null?void 0:e.getItem(r))!=null?a:null;return c instanceof Promise?c.then(i):i(c)},setItem:(r,e)=>{var a;return(a=t())==null?void 0:a.setItem(r,JSON.stringify(e))},removeItem:r=>{var e;return(e=t())==null?void 0:e.removeItem(r)}};return typeof window<"u"&&typeof window.addEventListener=="function"&&(s.subscribe=(r,e)=>{const a=i=>{i.key===r&&i.newValue&&e(JSON.parse(i.newValue))};return window.addEventListener("storage",a),()=>{window.removeEventListener("storage",a)}}),s}const mt=z(()=>typeof window<"u"?window.localStorage:void 0);function J(t,n,o=mt){const s=()=>{const e=o.getItem(t);return e instanceof Promise?e.then(a=>a===S?n:a):e===S?n:e},r=m(o.delayInit?n:s());return r.onMount=e=>{let a;if(o.subscribe&&(a=o.subscribe(t,e),e(s())),o.delayInit){const i=s();i instanceof Promise?i.then(e):e(i)}return a},m(e=>e(r),(e,a,i)=>{const c=typeof i=="function"?i(e(r)):i;return c===E?(a(r,n),o.removeItem(t)):(a(r,c),o.setItem(t,c))})}function ht(t,n,o){const s=(o==null?void 0:o.serialize)||JSON.stringify,r=(o==null?void 0:o.deserialize)||(i=>{try{return JSON.parse(i||"")}catch{return S}}),e=(o==null?void 0:o.subscribe)||(i=>(window.addEventListener("hashchange",i),()=>{window.removeEventListener("hashchange",i)})),a={getItem:i=>{if(typeof location>"u")return S;const c=new URLSearchParams(location.hash.slice(1)).get(i);return r(c)},setItem:(i,c)=>{const u=new URLSearchParams(location.hash.slice(1));u.set(i,s(c)),o!=null&&o.replaceState?history.replaceState(null,"",location.pathname+location.search+"#"+u.toString()):location.hash=u.toString()},removeItem:i=>{const c=new URLSearchParams(location.hash.slice(1));c.delete(i),o!=null&&o.replaceState?history.replaceState(null,"",location.pathname+location.search+"#"+c.toString()):location.hash=c.toString()},...(o==null?void 0:o.delayInit)&&{delayInit:!0},subscribe:(i,c)=>e(()=>{const u=new URLSearchParams(location.hash.slice(1)).get(i);c(u!==null?r(u):n)})};return J(t,n,a)}function dt(t,n){const o=m(s=>{var r;let e=t(s);const a=(r=e[Symbol.observable])==null?void 0:r.call(e);a&&(e=a);let i;const c=()=>new Promise(v=>{i=v}),u=n&&"initialValue"in n?{d:typeof n.initialValue=="function"?n.initialValue():n.initialValue}:c();let l,f;const d=v=>{f=v,i==null||i(v),l==null||l(v)};let h,y;const w=()=>!l,A=()=>{h&&(clearTimeout(y),h.unsubscribe()),h=e.subscribe({next:v=>d({d:v}),error:v=>d({e:v}),complete:()=>{}}),w()&&(n==null?void 0:n.unstable_timeout)&&(y=setTimeout(()=>{h&&(h.unsubscribe(),h=void 0)},n.unstable_timeout))};A();const R=m(f||u);return R.onMount=v=>(l=v,f&&v(f),h?clearTimeout(y):A(),()=>{l=void 0,h&&(h.unsubscribe(),h=void 0)}),[R,e,c,A,w]});return m(s=>{const[r]=s(o),e=s(r);if("e"in e)throw e.e;return e.d},(s,r,e)=>{const[a,i,c,u,l]=s(o);if("next"in i)l()&&(r(a,c()),u()),i.next(e);else throw new Error("observable is not subject")})}const D=new WeakMap;function bt(t,n){const o=W(n),s=I(o),r=s.s,e=vt(s),a=[];for(const i of t){const c=i[0];e.has(c)||(e.add(c),a.push(i))}a.length&&r[G](a)}function vt(t){let n=D.get(t);return n||(n=new WeakSet,D.set(t,n)),n}const wt=O(),At={state:"loading"};function gt(t){return wt(()=>{const n=new WeakMap,o=m(s=>{let r;try{const i=s(t);return m({state:"hasData",data:i})}catch(i){if(i instanceof Promise)r=i;else return m({state:"hasError",error:i})}const e=n.get(r);if(e)return e;const a=m(At,async(i,c)=>{try{const u=await i(t,{unstable_promise:!0});c(a,{state:"hasData",data:u})}catch(u){c(a,{state:"hasError",error:u})}});return a.onMount=i=>{i()},n.set(r,a),a});return m(s=>{const r=s(o);return s(r)})},[t])}function yt(t,n){return m(o=>{const s=new AbortController,r=t(o,{signal:s.signal});return r instanceof Promise&&V(r,()=>s.abort()),r},n)}}}});
